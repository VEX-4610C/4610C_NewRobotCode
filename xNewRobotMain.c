#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    PEStatus,       sensorAnalog)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftlimit,      sensorTouch)
#pragma config(Sensor, dgtl10, powerALED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, powerBLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, powerCLED,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           doubleLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mobileGoal,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           chainbar,      tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           doubleRight,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backLeft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
#define sign(x) (x < 0 ? -1 : 1)
#define toggle(x) (1 - x)
#include "Vex_Competition_Includes.c"
#include "zSmartMotorLib.c"
#include "zBCIPIDLib.c"

//CONFIG PARAMETERS
int doubleDown = 0;
int doubleUp[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int doublePreload = 100;
int doubleSetpoint = doubleDown;
int doubleKP = 25, doubleKI = 0, doubleKD = 7, doubleDIVISOR = 100;
int doubleDone = 0;
int doubleStackLoader = 0;
int doublePIDActive = 1;

int mobileGoalDown = 1750;
int mobileGoalUp = 0;
int mobileGoalSetpoint = mobileGoalUp;
int mobileKP = 25, mobileKI = 0, mobileKD = 7, mobileDIVISOR = 100;
int mobileDone = 0;
int mobilePIDActive = 1;

int chainBarUp = 0;
int chainBarDown = 2000;
int chainBarSetpoint = chainBarUp;
int chainBarKP = 25, chainBarKI = 0, chainBarKD = 7, chainBarDIVISOR = 100;
int chainBarDone = 0;
int chainBarPIDActive = 1;

int clawOpen = 0;
int clawClosed = 2000;
int clawSetpoint = clawOpen;
int clawKP = 25, clawKI = 0, clawKD = 7, clawDIVISOR = 100;
int clawDone = 0;
int clawPIDActive = 1;

int activateAutoStacker = 0;
int currentStacked = 0;

task WATCHDOG
{
	int doubleStartTimer, doubleEndTime;
	int mobileStartTimer, mobileEndTime;
	int chainBarStartTimer, chainBarEndTime;
	int clawStartTimer, clawEndTime;
	// DR4B PID Controller
	pos_PID doublePID;
	pos_PID_InitController(&doublePID, doubleRight, doubleKP, doubleKI, doubleKD);
	// Chain Bar PID Controller
	pos_PID chainbarPID;
	pos_PID_InitController(&chainbarPID, chainbar, chainBarKP, chainBarKI, chainBarKD);
	// Mobile Goal PID Controller
	pos_PID mobilePID;
	pos_PID_InitController(&mobilePID, mobileGoal, mobileKP, mobileKI, mobileKD);
	// Claw PID Controller
	pos_PID clawPIDController;
	pos_PID_InitController(&clawPIDController, clawPot, clawKP, clawKI, clawKD);

	while(1)
	{
		pos_PID_SetTargetPosition(&doublePID, doubleSetpoint);
		pos_PID_SetTargetPosition(&chainbarPID, chainBarSetpoint);
		pos_PID_SetTargetPosition(&mobilePID, mobileGoalSetpoint);
		pos_PID_SetTargetPosition(&clawPIDController, clawSetpoint);
		if(doublePIDActive)
		{
			SetMotor(doubleRight, pos_PID_StepController(&doublePID) / doubleDIVISOR);
			SetMotor(doubleLeft, pos_PID_StepController(&doublePID) / doubleDIVISOR);
		}
		if(chainBarPIDActive)
		{
			SetMotor(chainbar, pos_PID_StepController(&chainbarPID) / chainBarDIVISOR);
		}
		if(mobilePIDActive)
		{
			SetMotor(mobileGoal, pos_PID_StepController(&mobilePID) / mobileDIVISOR);
		}
		if(clawPIDActive)
		{
			SetMotor(claw, pos_PID_StepController(&clawPIDController) / clawDIVISOR);
		}
		// Dones
		if(abs(pos_PID_GetError(&doublePID)) < 50)
		{
			if(doubleStartTimer == 0)
				doubleEndTime = time10[T1] + 75;
			doubleStartTimer = 1;
		}
		else
		{
			doubleStartTimer = 0;
		}
		if(doubleStartTimer && time10[T1] > doubleEndTime)
		{
			doubleDone = 1;
		}
		else
		{
			doubleDone = 0;
		}
		if(abs(pos_PID_GetError(&mobilePID)) < 50)
		{
			if(mobileStartTimer == 0)
				mobileEndTime = time10[T1] + 75;
			mobileStartTimer = 1;
		}
		else
		{
			mobileStartTimer = 0;
		}
		if(mobileStartTimer && time10[T1] > mobileEndTime)
		{
			mobileDone = 1;
		}
		else
		{
			mobileDone = 0;
		}
		if(abs(pos_PID_GetError(&chainbarPID)) < 50)
		{
			if(chainBarStartTimer == 0)
				chainBarEndTime = time10[T1] + 75;
			chainBarStartTimer = 1;
		}
		else
		{
			chainBarStartTimer = 0;
		}
		if(chainBarStartTimer && time10[T1] > chainBarEndTime)
		{
			chainBarDone = 1;
		}
		else
		{
			chainBarDone = 0;
		}
		if(abs(pos_PID_GetError(&clawPIDController)) < 50)
		{
			if(clawStartTimer == 0)
				clawEndTime = time10[T1] + 75;
			clawStartTimer = 1;
		}
		else
		{
			clawStartTimer = 0;
		}
		if(clawStartTimer && time10[T1] > clawEndTime)
		{
			clawDone = 1;
		}
		else
		{
			clawDone = 0;
		}
		wait1Msec(25);
	}
}
task autoStacker
{
	int innerState = 0;
	int lastAutostacker = 0;
	/* ORDER OF ACTIONS:
	1. Close Claw
	2. Lift DR4B
	3. Lift Chainbar
	4. Open Claw
	5. Lower Chainbar
	6. Lower DR4B
	*/
	while(1)
	{
		if(activateAutoStacker && !lastAutostacker)
		{
			innerState = 0;
		}
		if(activateAutoStacker)
		{
			if(innerState == 0)
			{
				clawSetpoint = clawClosed;
				innerState++;
			}
			else if(innerState == 1)
			{
				if(clawDone)
				{
					doubleSetpoint = doubleUp[currentStacked];
					innerState++;
				}
			}
			else if(innerState == 2)
			{
				if(doubleDone)
				{
					chainBarSetpoint = chainBarUp;
					innerState++;
				}
			}
			else if(innerState == 3)
			{
				if(chainBarDone)
				{
					clawSetpoint = clawOpen;
					innerState++;
				}
			}
			else if(innerState == 4)
			{
				if(clawDone)
				{
					chainBarSetpoint = chainBarDown;
					innerState++;
				}
			}
			else if(innerState == 5)
			{
				if(chainBarDone)
				{
					doubleSetpoint = doubleDown;
					innerState++;
				}
			}
			else if(innerState == 6)
			{
				if(doubleDone)
				{
					currentStacked ++;
					activateAutoStacker = 0;
					innerState = 0;
				}
			}
		}
	}
}
void pre_auton()
{
	SmartMotorsInit();
	SmartMotorPtcMonitorEnable();
	SmartMotorLinkMotors(frontLeft, backLeft);
	SmartMotorLinkMotors(frontRight, backRight);
	SmartMotorLinkMotors(doubleRight, doubleLeft);
	SmartMotorsAddPowerExtender(mobileGoal); // Place Correct Motors
	SmartMotorSetPowerExpanderStatusPort(PEStatus);
	SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_0, powerALED);
	SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_1, powerBLED);
	SmartMotorSetControllerStatusLed( SMLIB_PWREXP_PORT_0, powerCLED);
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	SmartMotorRun();
	startTask(WATCHDOG);
	AutonomousCodePlaceholderForTesting();
}

task usercontrol()
{
	startTask(WATCHDOG);
	startTask(autoStacker);
	SmartMotorRun();

	int left = 0, right = 0, reverseDrive = 0;
	int lastManualMobileGoal = 0;
	int lastManualLift = 0;
	int lastManualClaw = 0;
	while (true)
	{
		// Drive Code
		left  = abs(vexRT[Ch3]);
		right  = abs(vexRT[Ch2]);
		left = (5*left*left + 305*left + 3624)/1000;
		right = (5*right*right + 305*right + 3624)/1000;
		if(reverseDrive == 1)
		{
			motor[frontLeft] = motor[backLeft]   = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
			motor[frontRight] = motor[backRight] = ((int) right) * reverseDrive * sign(vexRT[Ch2]);
		}
		else
		{
			motor[frontLeft] = motor[backLeft]   = ((int) right) * reverseDrive * sign(vexRT[Ch2]);
			motor[frontRight] = motor[backRight] = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
		}
		if(vexRT[Btn8L])
		{
			while(vexRT[Btn8L]) { wait1Msec(20); }
			reverseDrive = toggle(reverseDrive);
		}

		// Mobile Goal
		if(vexRT[Btn5DXmtr2] || vexRT[Btn5UXmtr2])
		{
			mobilePIDActive = 0;
			lastManualMobileGoal = 1;
			SetMotor(mobileGoal, 127);
		}
		else if(vexRT[Btn6DXmtr2] || vexRT[Btn6UXmtr2])
		{
			mobilePIDActive = 0;
			lastManualMobileGoal = 1;
			SetMotor(mobileGoal, -127);
		}
		else if(mobilePIDActive == 0 && lastManualMobileGoal == 1)
		{
			mobilePIDActive = 1;
			mobileGoalSetpoint = nMotorEncoder[mobileGoal];
		}
		else if(vexRT[Btn7D])
		{
			mobilePIDActive = 1;
			mobileGoalSetpoint = mobileGoalDown;
		}
		else if(vexRT[Btn8D])
		{
			mobileGoalSetpoint = mobileGoalUp;
		}

		// Lift (Autostack and Manual)
		if(vexRT[Btn8DXmtr2] || vexRT[Btn8RXmtr2] || vexRT[Btn8LXmtr2] || vexRT[Btn8UXmtr2])
		{
			while(vexRT[Btn8L]) { wait1Msec(20); }
			doubleStackLoader = toggle(doubleStackLoader); // 0 -> 1-0 = 1 ; 1 -> 1-1 = 0 -- Toggle Shorthand
		}
		if(vexRT[Btn7L])
		{
			doublePIDActive = 0;
			SetMotor(doubleLeft, -65);
			SetMotor(doubleRight, -65);
			lastManualLift = 1;
		}
		else if(vexRT[Btn8R])
		{
			doublePIDActive = 0;
			SetMotor(doubleLeft, 65);
			SetMotor(doubleRight, 65);
			lastManualLift = 1;
		}
		else if(doublePIDActive == 0 && lastManualLift == 1)
		{
			doublePIDActive = 1;
			doubleSetpoint = nMotorEncoder[doubleRight];
		}
		else if(vexRT[Btn6U])
		{
			doublePIDActive = 1;
			activateAutoStacker = 1;
		}
		else
		{
			doublePIDActive = 1;
			if(doubleStackLoader)
			{
				doubleSetpoint = doublePreload;
			}
			else
			{
				doubleSetpoint = doubleDown;
			}
		}
		// Claw
		if(vexRT[Btn5D])
		{
			clawPIDActive = 0;
			SetMotor(claw, -127);
			lastManualClaw = 1;
		}
		if(vexRT[Btn6D])
		{
			clawPIDActive = 0;
			SetMotor(claw, 127);
			lastManualClaw = 1;
		}
		else if(lastManualClaw == 1)
		{
			clawPIDActive = 1;
			clawSetpoint = SensorValue[clawPot];
			lastManualClaw = 0;
		}
	}
}
