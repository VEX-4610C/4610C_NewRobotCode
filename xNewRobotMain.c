#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    PEStatus,       sensorAnalog)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  liftlimit,      sensorTouch)
#pragma config(Sensor, dgtl10, powerALED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, powerBLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, powerCLED,      sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           doubleLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mobileGoal,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           chainbar,      tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           doubleRight,   tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backLeft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)
// Sign is a ternary statment
#define sign(x) ((x) < 0 ? -1 : 1)
// toggle -- 1 -> (1-1)=0;  0 -> (1-0)=1
#define toggle(x) (1 - (x))
#define min(x,y) ((x) > (y) ? (y) : (x))
#define max(x,y) ((x) > (y) ? (x) : (y))
#define resetButton (vexRT[Btn7R])
#include "Vex_Competition_Includes.c"
/* include "zSmartMotorLib.c" */
#define SetMotor(x, y) (motor[(x)] = (y))
#define SmartMotorRun() ;
#include "zBCIPIDLib.c"
#include "zAutonomousFunctions.c"
#include "zAutonomousRoutines.c"

int RUNTEST = 1, TEST = 0; // Manual Autonomous Test Controls
void pre_auton()
{
	/* SmartMotorsInit();
	SmartMotorPtcMonitorEnable();
	SmartMotorLinkMotors(frontLeft, backLeft);
	SmartMotorLinkMotors(frontRight, backRight);
	SmartMotorLinkMotors(doubleRight, doubleLeft);
	SmartMotorsAddPowerExtender(mobileGoal); // Place Correct Motors
	SmartMotorSetPowerExpanderStatusPort(PEStatus);
	SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_0, powerALED);
	SmartMotorSetControllerStatusLed( SMLIB_CORTEX_PORT_1, powerBLED);
	SmartMotorSetControllerStatusLed( SMLIB_PWREXP_PORT_0, powerCLED); */
	bStopTasksBetweenModes = true;
	if(!RUNTEST)
		LcdAutonomousSelection();
}


task autonomous()
{
	SmartMotorRun();
	if(RUNTEST == 1 && TEST == 0)
		testDegmove();
	if(RUNTEST == 1 && TEST == 1)
		testSmallGyroturn();
	if(RUNTEST == 1 && TEST == 2)
		testLargeGyroturn();
}

task usercontrol()
{
	startTask(WATCHDOG);
	startTask(autoStacker);
	SmartMotorRun();
	int EMERGENCY_MODE = 0;
	int left = 0, right = 0, reverseDrive = 0;
	int lastManualMobileGoal = 0;
	int lastManualLift = 0;
	int lastManualClaw = 0;
	int lastManualChainBar = 0;
	while (true)
	{
		// Drive Code
		left  = abs(vexRT[Ch3]);
		right  = abs(vexRT[Ch2]);
		left = (5*left*left + 305*left + 3624)/1000;
		right = (5*right*right + 305*right + 3624)/1000;
		if(reverseDrive == 1)
		{
			motor[frontLeft] = motor[backLeft]   = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
			motor[frontRight] = motor[backRight] = ((int) right) * reverseDrive * sign(vexRT[Ch2]);
		}
		else
		{
			motor[frontLeft] = motor[backLeft]   = ((int) right) * reverseDrive * sign(vexRT[Ch2]);
			motor[frontRight] = motor[backRight] = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
		}
		if(vexRT[Btn8L])
		{
			while(vexRT[Btn8L]) { wait1Msec(20); }
			reverseDrive = toggle(reverseDrive);
		}

		if(vexRT[Btn8U])
		{
			while(vexRT[Btn8U]) { wait1Msec(20); }
			EMERGENCY_MODE = toggle(EMERGENCY_MODE);
		}
		if(EMERGENCY_MODE)
		{
			pidActive = 0;
			activateAutoStacker = 0;
		}
		else
		{
			pidActive = 1;
		}

		// Mobile Goal
		if(EMERGENCY_MODE && vexRT[Btn5D])
		{
			mobilePIDActive = 0;
			lastManualMobileGoal = 1;
			SetMotor(mobileGoal, 127);
		}
		else if(EMERGENCY_MODE && vexRT[Btn6DXmtr2])
		{
			mobilePIDActive = 0;
			lastManualMobileGoal = 1;
			SetMotor(mobileGoal, -127);
		}
		else if(mobilePIDActive == 0 && lastManualMobileGoal == 1)
		{
			mobilePIDActive = 1;
			mobileGoalSetpoint = nMotorEncoder[mobileGoal];
		}
		else if(vexRT[Btn7D])
		{
			mobilePIDActive = 1;
			mobileGoalSetpoint = mobileGoalDown;
		}
		else if(vexRT[Btn8D])
		{
			mobilePIDActive = 1;
			mobileGoalSetpoint = mobileGoalUp;
		}

		// Lift (Autostack and Manual)
		if(vexRT[Btn7R])
		{
			while(vexRT[Btn7R]) { wait1Msec(20); }
			doubleStackLoader = toggle(doubleStackLoader); // 0 -> 1-0 = 1 ; 1 -> 1-1 = 0 -- Toggle Shorthand
		}

		if(EMERGENCY_MODE && vexRT[Btn7L])
		{
			SetMotor(doubleLeft, -65);
			SetMotor(doubleRight, -65);
		}
		else if(EMERGENCY_MODE && vexRT[Btn8R])
		{
			SetMotor(doubleLeft, 65);
			SetMotor(doubleRight, 65);
		}
		else if(EMERGENCY_MODE)
		{
			SetMotor(doubleLeft, 12);
			SetMotor(doubleRight, 12);
		}
		else if(!EMERGENCY_MODE && vexRT[Btn7L])
		{
			doublePIDActive = 0;
			SetMotor(doubleLeft, -65);
			SetMotor(doubleRight, -65);
			lastManualLift = 1;
		}
		else if(!EMERGENCY_MODE && vexRT[Btn8R])
		{
			doublePIDActive = 0;
			SetMotor(doubleLeft, 65);
			SetMotor(doubleRight, 65);
			lastManualLift = 1;
		}
		else if(doublePIDActive == 0 && lastManualLift == 1)
		{
			doublePIDActive = 1;
			doubleSetpoint = nMotorEncoder[doubleRight];
		}
		else if(vexRT[Btn6U])
		{
			doublePIDActive = 1;
			activateAutoStacker = 1;
		}
		else
		{
			doublePIDActive = 1;
			if(doubleStackLoader && mobileDone)
			{
				doubleSetpoint = doublePreload;
			}
			else if(mobileDone)
			{
				doubleSetpoint = doubleDown;
			}
		}

		// Chainbar
		if(vexRT[Btn5U])
		{
			chainBarPIDActive = 0;
			SetMotor(chainbar, -127);
			lastManualChainBar = 1;
		}
		if(vexRT[Btn6U])
		{
			chainBarPIDActive = 0;
			SetMotor(chainbar, 127);
			lastManualChainBar = 1;
		}
		else if(lastManualClaw == 1)
		{
			chainBarPIDActive = 1;
			chainBarSetpoint = nMotorEncoder[chainbar];
			lastManualChainBar = 0;
		}
		// Claw
		if(vexRT[Btn5D])
		{
			clawPIDActive = 0;
			SetMotor(claw, -127);
			lastManualClaw = 1;
		}
		if(vexRT[Btn6D])
		{
			clawPIDActive = 0;
			SetMotor(claw, 127);
			lastManualClaw = 1;
		}
		else if(lastManualClaw == 1)
		{
			clawPIDActive = 1;
			clawSetpoint = SensorValue[clawPot];
			lastManualClaw = 0;
		}
	}
}
